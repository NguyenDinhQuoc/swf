# imports
import os
import numpy as np
from qsketch import sketch
import IDT
from IDT import batchIDT, Chain, add_IDT_arguments, add_plotting_arguments
import argparse
from tensorboardX import SummaryWriter
from time import strftime, gmtime
import socket
import matplotlib.pyplot as plt
plt.ion()

if __name__ == "__main__":
    # create arguments parser and parse arguments
    parser = argparse.ArgumentParser(description=
                                     'Performs iterative distribution transfer'
                                     ' with sliced Wasserstein flow.')
    parser.add_argument("sketch_file", help="Path to the "
                        "sketch file as generated by the `sketch.py` script. ")
    parser = add_IDT_arguments(parser)
    parser = add_plotting_arguments(parser)

    parser.add_argument("--output",
                        help="If provided, save the generated samples to "
                             "this file path after transportation")
    parser.add_argument("--input_chain",
                        help="Input chain to use, as returned by this same "
                             "script. If provided, overrides any other of "
                             "the parameters `epochs`, `dim`, `lambda`")
    parser.add_argument("--output_chain",
                        help="keep output chain, and save it to "
                             "provided filepath")
    parser.add_argument("--epochs",
                        help="Number of epochs",
                        type=int,
                        default=10)

    args = parser.parse_args()

    # load the sketch data and create the projectors object
    sketch_data = np.load(args.sketch_file).item()
    target_qf = sketch_data['qf']
    data_dim = sketch_data['data_dim']
    [num_sketches, num_thetas, num_quantiles] = target_qf.shape
    ProjectorClass = getattr(sketch, sketch_data['projectors_class'])
    projectors = ProjectorClass(num_sketches, num_thetas, data_dim)

    # if no input chain is provided, create one (contains the parameters for
    # the IDT algorithm)
    if args.input_chain is not None:
        input_chain = np.load(args.input_chain).item()
    else:
        input_chain = Chain(args.batchsize, args.epochs,
                            args.stepsize, args.reg)

    # get the initial samples
    if args.initial_samples is None:
        # If no samples are provided, generate random ones
        samples = np.random.randn(args.num_samples, args.input_dim)*1e-10
        # if required, transform the samples to the data_dim
        if args.input_dim != data_dim:
            np.random.seed(0)
            up_sampling = np.random.randn(args.input_dim, data_dim)
            samples = np.dot(samples, up_sampling)
    else:
        # if a samples file is given, load it
        samples = np.load(args.initial_samples)
        if len(samples.shape) != 2 or samples.shape[1] != data_dim:
            raise ValueError('Samples in %s do not have the right shape. '
                             'They should be num_samples x %d for this '
                             'sketch file.' % (args.initial_samples, data_dim))

    # the output chain, if asked for, will contain the parmeters computed
    # during this iteration
    if args.output_chain is not None:
        compute_output_chain = True
    else:
        compute_output_chain = False

    # now create the plotting function
    # --------------------------------
    if args.log:
        log_writer = SummaryWriter(os.path.join(args.logdir,
                                                strftime('%Y-%m-%d-%h-%s-',
                                                         gmtime())
                                                + socket.gethostname()))
    else:
        log_writer = None

    # if we have some plot target, these are samples from the original data
    if args.plot_target is not None:
        # just handle numpy arrays now
        target_samples = sketch.load_data(args.plot_target, None).dataset.data
        data_dim = target_samples.shape[1]

        ntarget = min(10000, target_samples.shape[0])
        target_samples = target_samples[:ntarget]
        axis_lim = [[v.min(), v.max()] for v in target_samples.T]
    else:
        target_samples = None

    # now create the callback plotting function
    def plot_function(samples, index, error):
        return IDT.base_plot_function(samples, index, error, log_writer,
                                      args, axis_lim, target_samples,
                                      args.contour_every)

    # now call the actual IDT function
    samples, chain_out = batchIDT(target_qf, projectors,
                                  input_chain, samples, plot_function,
                                  compute_output_chain)

    # save the output chain if asked to do it
    if compute_output_chain:
        np.save(args.output_chain, chain_out)

    # if the resulting samples are asked for, write them to disk
    if args.output is not None:
        np.save(args.output, samples)
