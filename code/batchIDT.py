# imports
import os
import torch
from torchvision.utils import save_image, make_grid
import numpy as np
from qsketch import sketch
from IDT import batchIDT, Chain, add_IDT_arguments
import argparse
import matplotlib.pyplot as plt
plt.ion()

if __name__ == "__main__":
    # create arguments parser and parse arguments
    parser = argparse.ArgumentParser(description=
                                     'Performs iterative distribution transfer'
                                     ' with sliced Wasserstein flow.')
    parser.add_argument("sketch_file", help="Path to the "
                        "sketch file as generated by the `sketch.py` script. ")
    parser = add_IDT_arguments(parser)
    parser.add_argument("--output",
                        help="If provided, save the generated samples to "
                             "this file path after transportation")
    parser.add_argument("--input_chain",
                        help="Input chain to use, as returned by this same "
                             "script. If provided, overrides any other of "
                             "the parameters `epochs`, `dim`, `lambda`")
    parser.add_argument("--output_chain",
                        help="keep output chain, and save it to "
                             "provided filepath")
    parser.add_argument("--epochs",
                        help="Number of epochs",
                        type=int,
                        default=10)
    parser.add_argument("--plot",
                        help="Flag indicating whether or not to plot samples",
                        action="store_true")
    parser.add_argument("--plot_target",
                        help="Samples from the target. Same constraints as "
                             "the `dataset` argument.")
    parser.add_argument("--plot_dir",
                        help="Output directory for saving the plots",
                        default="./samples")

    args = parser.parse_args()

    # load the sketch data and create the projectors object
    sketch_data = np.load(args.sketch_file).item()
    target_qf = sketch_data['qf']
    data_dim = sketch_data['data_dim']
    [num_sketches, num_thetas, num_quantiles] = target_qf.shape
    ProjectorClass = getattr(sketch, sketch_data['projectors_class'])
    projectors = ProjectorClass(num_sketches, num_thetas, data_dim)

    # if no input chain is provided, create one (contains the parameters for
    # the IDT algorithm)
    if args.input_chain is not None:
        input_chain = np.load(args.input_chain).item()
    else:
        input_chain = Chain(args.batchsize, args.epochs,
                            args.stepsize, args.reg)

    # get the initial samples
    if args.initial_samples is None:
        # If no samples are provided, generate random ones
        samples = np.random.randn(args.num_samples, args.input_dim)*1e-10
        # if required, transform the samples to the data_dim
        if args.input_dim != data_dim:
            np.random.seed(0)
            up_sampling = np.random.randn(args.input_dim, data_dim)
            samples = np.dot(samples, up_sampling)
    else:
        # if a samples file is given, load it
        samples = np.load(args.initial_samples)
        if len(samples.shape) != 2 or samples.shape[1] != data_dim:
            raise ValueError('Samples in %s do not have the right shape. '
                             'They should be num_samples x %d for this '
                             'sketch file.' % (args.initial_samples, data_dim))

    # the output chain, if asked for, will contain the parmeters computed
    # during this iteration
    if args.output_chain is not None:
        compute_output_chain = True
    else:
        compute_output_chain = False

    # now create the plotting function
    # --------------------------------

    # if we have some plot target, these are samples from the original data
    if args.plot_target is not None:
        # just handle numpy arrays now
        target_samples = sketch.load_data(args.plot_target, None).dataset.data
        data_dim = target_samples.shape[1]

        ntarget = min(10000, target_samples.shape[0])
        target_samples = target_samples[:ntarget]
        axis_lim = [[v.min(), v.max()] for v in target_samples.T]

    # now create the callback plotting function
    if args.plot:
        if not os.path.exists(args.plot_dir):
            os.mkdir(args.plot_dir)

        def plot_function(samples, index):
            if index % 200:
                return

            data_dim = samples.shape[-1]
            image = False

            # try to identify if it's an image or not
            if data_dim > 700:
                # if the data dimension is large: probably an image.
                square_dim_bw = np.sqrt(data_dim)
                square_dim_col = np.sqrt(data_dim/3)
                if not (square_dim_col % 1):  # check monochrome
                    image = True
                    nchan = 3
                    img_dim = int(square_dim_col)
                elif not (square_dim_bw % 1):  # check color
                    image = True
                    nchan = 1
                    img_dim = int(square_dim_bw)

            if not image:
                # no image: just plot second data dimension vs first one
                plt.figure(1, figsize=(8, 8))
                plt.clf()
                if args.plot_target is not None:
                    plt.plot(target_samples[:, 0], target_samples[:, 1], 'or')
                plt.plot(samples[:, 0], samples[:, 1], 'ob')
                plt.xlim(axis_lim[0])
                plt.ylim(axis_lim[1])
                plt.grid(True)
                plt.title('Sketch %d'
                          % (index+1))
                plt.pause(0.05)
                plt.show()
                return

            # it's an image, output a grid of samples
            [num_samples, data_dim] = samples.shape
            samples = samples[:min(208, num_samples)]
            num_samples = samples.shape[0]

            samples = np.reshape(samples,
                                 [num_samples, nchan, img_dim, img_dim])
            pic = make_grid(torch.Tensor(samples),
                            nrow=8, padding=2, normalize=True, scale_each=True)
            save_image(pic, '{}/image_{}.png'.format(args.plot_dir, index))
    else:
        plot_function = None

    # now call the actual IDT function
    samples, chain_out = batchIDT(target_qf, projectors, num_quantiles,
                                  input_chain, samples, plot_function,
                                  args.logdir, compute_output_chain)

    # save the output chain if asked to do it
    if compute_output_chain:
        np.save(args.output_chain, chain_out)

    # if the resulting samples are asked for, write them to disk
    if args.output is not None:
        np.save(args.output, samples)
